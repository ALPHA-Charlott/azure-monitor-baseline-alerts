let resourceTypes = MetricAlertRules(ago(1d))
| summarize numRulesRt=dcount(RuleId) by resourceType=tolower(resourceType)
| where numRulesRt > 1000
| order by numRulesRt;

MetricAlertRules(ago(1d))
| where tolower(resourceType) in (resourceTypes)
| mv-expand allCriteria
| extend metricName=tolower(parse_json(allCriteria)["metricName"]),
        operator=tolower(parse_json(allCriteria)["operator"]),
        timeAggregation=tolower(parse_json(allCriteria)["timeAggregation"]),
        criterionType=tolower(parse_json(allCriteria)["criterionType"])
| summarize id=max(RuleId), numRules=dcount(RuleId) by resourceType, metricName, operator, timeAggregation, criterionType
| partition hint.strategy=native by metricName
    (
        top 3 by numRules
    )
| order by metricName asc, numRules desc
| lookup kind=inner
    (
        MetricAlertRules(ago(1d))
        | where resourceType =~ resourceType
        | mv-expand allCriteria
        | extend metricName=tolower(parse_json(allCriteria)["metricName"]),
                operator=tolower(parse_json(allCriteria)["operator"]),
                timeAggregation=tolower(parse_json(allCriteria)["timeAggregation"]),
                criterionType=tolower(parse_json(allCriteria)["criterionType"])
        | where metricName == metricName and operator == operator and timeAggregation == timeAggregation and criterionType == criterionType
        | extend freq_winsize = tostring(bag_pack("frequency", frequency, "windowSize", windowSize))
        | extend group = tostring(bag_pack("resourceType", tolower(resourceType), "metricName", metricName, "operator", operator, "timeAggregation", timeAggregation, "criterionType", criterionType))
        | summarize numRules1=dcount(RuleId) by group, freq_winsize
        | partition hint.strategy=native by group
            (
                top 3 by numRules1
            )
        | order by group, numRules1
        | extend a = parse_json(freq_winsize)
        | extend b = bag_pack("frequency", a['frequency'], "windowSize", a['windowSize'], "numRules", numRules1)
        | summarize freq_winsize_list = make_list(b) by group
        | extend c = parse_json(group)
        | evaluate bag_unpack(c)
        | project resourceType, metricName, operator, timeAggregation, criterionType, freq_winsize_list
    ) on resourceType, metricName, operator, timeAggregation, criterionType
| lookup kind=inner
    (
        MetricAlertRules(ago(1d))
        | where resourceType =~ resourceType
        | mv-expand allCriteria
        | extend metricName=tolower(parse_json(allCriteria)["metricName"]),
                operator=tolower(parse_json(allCriteria)["operator"]),
                timeAggregation=tolower(parse_json(allCriteria)["timeAggregation"]),
                criterionType=tolower(parse_json(allCriteria)["criterionType"]),
                dimensions=tolower(parse_json(allCriteria)["dimensions"])
        | where metricName == metricName and operator == operator and timeAggregation == timeAggregation and criterionType == criterionType
        | extend group = tostring(bag_pack("resourceType", tolower(resourceType), "metricName", metricName, "operator", operator, "timeAggregation", timeAggregation, "criterionType", criterionType))
        | summarize numRules2=dcount(RuleId) by group, dimensions
        | partition hint.strategy=native by group
            (
                top 3 by numRules2
            )
        | order by group, numRules2
        | extend a = bag_pack("dimensions", dimensions, "numRules", numRules2)
        | summarize dimensions_list = make_list(a) by group
        | extend b = parse_json(group)
        | evaluate bag_unpack(b)
        | project resourceType, metricName, operator, timeAggregation, criterionType, dimensions_list
    ) on resourceType, metricName, operator, timeAggregation, criterionType
| lookup kind=inner
    (
        MetricAlertRules(ago(1d))
        | where resourceType =~ resourceType
        | mv-expand allCriteria
        | extend metricName=tolower(parse_json(allCriteria)["metricName"]),
                operator=tolower(parse_json(allCriteria)["operator"]),
                timeAggregation=tolower(parse_json(allCriteria)["timeAggregation"]),
                criterionType=tolower(parse_json(allCriteria)["criterionType"]),
                severity=toint(parse_json(JsonPayload)["genevaAlertMonitor"]["properties"]["severity"])
        | where metricName == metricName and operator == operator and timeAggregation == timeAggregation and criterionType == criterionType
        | extend group = tostring(bag_pack("resourceType", tolower(resourceType), "metricName", metricName, "operator", operator, "timeAggregation", timeAggregation, "criterionType", criterionType))
        | summarize numRules3=dcount(RuleId) by group, severity
        | partition hint.strategy=native by group
            (
                top 3 by numRules3
            )
        | order by group, numRules3
        | extend a = bag_pack("severity", severity, "numRules", numRules3)
        | summarize severity_list = make_list(a) by group
        | extend b = parse_json(group)
        | evaluate bag_unpack(b)
        | project resourceType, metricName, operator, timeAggregation, criterionType, severity_list
    ) on resourceType, metricName, operator, timeAggregation, criterionType
| lookup kind=inner
    (
        MetricAlertRules(ago(1d))
        | where resourceType =~ resourceType
        | mv-expand allCriteria
        | extend metricName=tolower(parse_json(allCriteria)["metricName"]),
                operator=tolower(parse_json(allCriteria)["operator"]),
                timeAggregation=tolower(parse_json(allCriteria)["timeAggregation"]),
                criterionType=tolower(parse_json(allCriteria)["criterionType"]),
                threshold=tolower(parse_json(allCriteria)["threshold"])
        | where metricName == metricName and operator == operator and timeAggregation == timeAggregation and criterionType == criterionType
        | extend group = tostring(bag_pack("resourceType", tolower(resourceType), "metricName", metricName, "operator", operator, "timeAggregation", timeAggregation, "criterionType", criterionType))
        | summarize numRules4=dcount(RuleId) by group, threshold
        | partition hint.strategy=native by group
            (
                top 3 by numRules4
            )
        | order by group, numRules4
        | extend a = bag_pack("threshold", threshold, "numRules", numRules4)
        | summarize static_threshold_list = make_list(a) by group
        | extend b = parse_json(group)
        | evaluate bag_unpack(b)
        | project resourceType, metricName, operator, timeAggregation, criterionType, static_threshold_list
    ) on resourceType, metricName, operator, timeAggregation, criterionType
| lookup kind=inner
    (
        MetricAlertRules(ago(1d))
        | where resourceType =~ resourceType
        | mv-expand allCriteria
        | extend metricName=tolower(parse_json(allCriteria)["metricName"]),
                operator=tolower(parse_json(allCriteria)["operator"]),
                timeAggregation=tolower(parse_json(allCriteria)["timeAggregation"]),
                criterionType=tolower(parse_json(allCriteria)["criterionType"]),
                alertSensitivity=tolower(parse_json(allCriteria)["alertSensitivity"]),
                numberOfEvaluationPeriods=toint(parse_json(allCriteria)["failingPeriods"]["numberOfEvaluationPeriods"]),
                minFailingPeriodsToAlert=toint(parse_json(allCriteria)["failingPeriods"]["minFailingPeriodsToAlert"])
        | where metricName == metricName and operator == operator and timeAggregation == timeAggregation and criterionType == criterionType
        | extend dynamic_threshold = tostring(bag_pack("alertSensitivity", alertSensitivity, "numberOfEvaluationPeriods", numberOfEvaluationPeriods, "minFailingPeriodsToAlert", minFailingPeriodsToAlert))
        | extend group = tostring(bag_pack("resourceType", tolower(resourceType), "metricName", metricName, "operator", operator, "timeAggregation", timeAggregation, "criterionType", criterionType))
        | summarize numRules5=dcount(RuleId) by group, dynamic_threshold
        | partition hint.strategy=native by group
            (
                top 3 by numRules5
            )
        | order by group, numRules5
        | extend a = parse_json(dynamic_threshold)
        | extend b = bag_pack("alertSensitivity", a["alertSensitivity"], "numberOfEvaluationPeriods", a["numberOfEvaluationPeriods"], "minFailingPeroidsToAlert", a["minFailingPeroidsToAlert"], "numRules", numRules5)
        | summarize dynamic_threshold_list = make_list(b) by group
        | extend c = parse_json(group)
        | evaluate bag_unpack(c)
        | project resourceType, metricName, operator, timeAggregation, criterionType, dynamic_threshold_list
    ) on resourceType, metricName, operator, timeAggregation, criterionType
| extend frequency = freq_winsize_list[0]["frequency"]
| extend windowSize = freq_winsize_list[0]["windowSize"]
| extend severity = severity_list[0]["severity"]
| extend dimensions = dimensions_list[0]["dimensions"]
| extend threshold = iif(criterionType =~ "StaticThresholdCriterion", static_threshold_list[0]["threshold"], "")
| extend alertSensitivity = iif(criterionType =~ "DynamicThresholdCriterion", dynamic_threshold_list[0]["alertSensitivity"], "")
| extend failingPeriods = iif(criterionType =~ "DynamicThresholdCriterion", bag_pack("numberOfEvaluationPeriods", dynamic_threshold_list[0]["numberOfEvaluationPeriods"], "minFailingPeroidsToAlert", dynamic_threshold_list[0]["minFailingPeroidsToAlert"]), "")
| extend analysis = bag_pack("freq_winsize_list", freq_winsize_list, "severity_list", severity_list, "dimensions_list", dimensions_list, "static_threshold_list", static_threshold_list, "dynamic_threshold_list", dynamic_threshold_list)
| lookup kind=inner
    (
        resourceTypes
    ) on resourceType
| project resourceType, numRulesRt, metricName, numRules, operator, timeAggregation, criterionType, frequency, windowSize, severity, dimensions, threshold, alertSensitivity, failingPeriods, analysis
| order by numRulesRt desc, resourceType asc, metricName asc, numRules desc
